<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>圆角推内存，直角栈内存</title>
</head>
<body>
    
</body>
</html>
<script>
/***********************    作用域    ******************************/

/*
栈内存： 存储值类型，提供代码运行环境
堆内存： 存储引用数据类型
js中的作用域：（就是指一块‘栈’内存）
    全局作用域 ：页面一打开就会形成全局作用域
    私有作用域 ：只有在函数执行的时候才会形成私有作用域
    块级作用域 ：在es6中 所有的{} 排除对象都是块级。if for while

全局变量：在全局声明的变量叫做全局变量
私有变量：在私有作用域声明的变量就是私有变量  ，形参也是私有变量  

上级作用域：外层作用域：查找规律：上级作用域是谁，就看这个函数是在那个作用域下声明定义的
          对于私有作用域中的某些变量，若没有在私有作用域中声明过，那么函数执行时就会去上级作用域查找该变量。
          上级作用域中若没有该变量，会继续向上查找，直到报错结束。


函数执行的过程：
先开辟一个私有作用域（也就是栈内存），然后给形参赋值（函数传参不传参都是有赋值的，因为默认值就是undefined），然后在执行变量提升。然后代码从上到下执行。

函数中的私有变量：
形参，和在私有作用域中声明过的变量，剩下的变量都是上级作用域的。

es6针对let和const声明的变量，多了一个块级作用域（{}）；这个大括号不是对象。理解成私有作用域就可以了。


作用域链：变量的查找机制，一直向上级作用域查找

*/
    var a =12; //全局变量
    var  f = function(){
        console.log(a)  //undefined 存在变量提升的原因
        var a =100; //私有变量
        console.log(a) //100 内部复制为100 
    }
    f()//在代码执行之前，就有变量提升的这个阶段
    console.log(a) //12,全局和私有两个不是同一个东西
                    
/****************************      两个对比看          ***************************/
    var n=10;
    var f2=function(){
        console.log(n)//10 
        n=200;
        console.log(n)//200
    }
    f2()
    console.log(n)//200

    /**
    var f3=function(c){
        //先形参赋值，在变量提升
        let c =100;
    }
// 暂时性死区：在let和const之前不能使用他们声明的任何变量
    var d=10;
    var f4=function(){
        console.log(d)
        // let d=100;
    }
    f4(); */


/**/
        if(1<2){
            var e =12;
            let z =13;
        }
        console.log(e);
        console.log(z);



</script>