### 函数的两种声明方式
    var f = function (){}
    function f(){}
    var f =()=>{}

>形参 实参 
                var f=function(a=10,b=100,...c){
                        //  a=a||10;b=b||100; 
                    console.log(c)
                    return a+b
                }
                f(1,2);
                f(1);
                f();

    (形参默认值：a=a||10;b=b||100; 
                形参=形参||默认值 ，这是es6之前的赋值方法
                es6之后  就是直接赋值：a=10，b=100；
    )
    (剩余运算符： ...形参c; 
                把剩余的所有实参都放到c这个形参对应数组中去
    )

                var f=(..ary)=>{
                    console.log(ary)
                }
                f(1,2,3,4)
                f(1,2)

    (arguments实参集合)

    (this 函数的执行主体 谁让这个函数执行的)
    (return 一个决定返回值 另一个是打断函数的执行)

### 变量提示
            f();
            var f =()=>{
                console.log(1)
            }
            f();
            var f () {
                console.log(2)
            }
            f();

* js 代码执行之前，先把代码中带var和带function的提前声明了，var只声明不定义，function是声明+定义
* let const 暂时性死区，也就是在let之前绝对不能调用对应的变量，一调用就报错。
* 变量提升只会提升等号左边的部分
* var 出来的变量会在window增加一个对应属性：window是全局大对象
* let const 声明的变量，不会再window中增加对应的属性
  
### 堆栈内存
    if(1<2){
        let a=123;
    }
    console.log(a);  //这样就会报错

+ 栈内存 ： 存储值类型，提供代码的运行环境；
+ 堆内存 ： 存储引用数据类型；
+ 作用域 ： 每个作用域就是js中的一个栈内存；
+          全局作用域：页面打开的一瞬间就形成了。页面关闭时全局作用域销毁。
+          私有作用域：在函数执行的时候才会形成。一般执行完函数后作用域就会销毁。但是，函数的返回值若是引用数据类型，则不能销毁。
>                     全局变量：在全局声明的变量
>                     私有变量：在私有作用域中声明的变量，形参
>                     函数执行：先开辟一个私有作用域，形参赋值 变量提升 代码执行
+          块状作用域：在es6之后，所有的{}（除了对象）都是块状作用域。只有let const 能识别块状作用域，var不可以。
+ 上级作用域 ： 一个私有作用域的上级作用域是看 该函数在哪儿声明的。跟函数在哪里执行没有关系。

### this函数执行主体
            var ary=[
                        1,
                        2,
                        function(){console.log(this)},
                        ()=>{console.log(this)};
                ];
                let f=ary[2];
                f();         //window
                ary[2]();    //ary.2() ary
                ary[3]();    //ary.3   //window

- 时间绑定中的this都是当前操作的元素
- 自执行函数中的this是window。
- 一般函数执行时，内部this 看’点‘，点前边是谁this就是谁

           