<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    /*


    */
</body>

</html>
<script>
    function Person(name, age) {
        this.name = name;
        this.age = age;
    }
    Person.prototype.eat = function () {
        console.log(`${this.name}吃饭`);
    }
    var per1 = new Person('老李', 22);
    // name age 属性是per1私有的，而eat属性是共有的。
    console.log(per1);
    console.log(per1.hasOwnProperty('eat'));
    // per1.hasOwnProperty('eat') 查看eat是否为per1的私有属性
    console.log('eat' in per1)
    console.log('qqq' in per1);
    // in 只看per1是否能够调用到 qqq，调到了就是true ，否则就是false，不管是否为共有和私有

/****************************  封装函数 hasOwnProperty 和他功能一样 ***********************/

    //用this获取per1。属性通过kew这个形参可以获取到。紧接着判断 key是否为this的共有属性？
    // 前提是，它是this 的属性。 同时还要满足它不能是私有属性。    
    Object.prototype.hasPubProperty = function (key) {
        if ((key in this) && !this.hasOwnProperty(key)) {
            return true
        }
        return false
    }
    console.log(per1.hasPubProperty('eat')); //true


/*******************************   instanceof   ******************************************/

    var ary = [];
    console.log(ary instanceof Array); //true
    console.log(ary instanceof Number); //false
    console.log(ary instanceof Object); //true
    // A instanceof B 就是看从A能不能通过原型链 链到B的原型，能就是true。A必须是引用数据类型，和B判断的时候就是true。如果A是值类型，那结果就是false


/********************  封装一个方法， myType()检测数据类型  ********************************/

    //this就是我们要去判断类型的数据（放在了基类上）
    Object.prototype.myType = function () {
        var str = ({}).toString.call(this);
        var str2 = str.slice(8, length - 1);
        var str3 = str2.toLowerCase();
        return str3
    }

    //类数组：元素集合 实参集合    
    function sum(...arg) {
        console.log(arg);
        arg.forEach((v, i) => {
            console.log(v, i);
        });
    }
    sum(1, 2)
</script>