### 函数的三种角色：
>    1.普通函数：
    形参 实参 this return arguments 作用域
>    2.构造函数：
    原型： prototype
    原型链： __proto__
    私有属性 共有属性 hasOwnproperty
    in instanceof
    new 执行 注意其中的this
>    3.作为普通对象

> （函数）
    普通函数  、  类（所有的类：内置类、自己创建的类）
>       js中的一些内置类：
            数组类Array  数字类Number  对象类Object  日期类Date  正则类RegExp  ... 
> （对象）
    普通对象、数组、正则、Math、arguments...
    实例是对象类型的，（除了基本类型的字面量创建的值）
    prototype的值也是对象类型的
    函数也是对象类型（Object是个内置类（基类），也就是个函数，是函数就是Function的实例，既然是实例就是对象类型，所以就天生自带__proto__属性，指向自己所属类的原型）

*   所有的函数数据类型天生自带  原型（prototype）属性，而她的属性值就是一个对象，存贮的还是共有的属性和方法。
*   每个对象都有一个 原型链（__proto__）属性，而她指向当前实例所属类的原型（prototype），若不确定就是object实例。
*   浏览器 ‘默认’ 给原型开辟的堆内存中，有一个constructor，存储的是当前类本身。    

####  每一个函数都有天生自带的prototype属性，指向自己的原型。函数的属性值是对象，每个对象还有一个__proto__属性，指向所属类的原型（prototype）每个实例都是一个对象,每一个默认的原型，都有一个constructor属性，指向构造函数本身。

* ctrl +d  就能实现多选更改

### 函数执行
>   1.普通函数
>       先开辟作用域，形参赋值，变量提升，   代码执行  return什么，函数的运行结果就是什么
>   2.构造函数 new执行
>       先开辟作用域，形参赋值，变量提升，    再开辟一个堆内存，把函数中的this指向这个堆内存，代码执行 return 默认返回this

### this
>   箭头函数中的this始终是上级作用域中的this，不会出现任何意外状况。箭头函数不能new，因为他没有constructor，更何况他还没有this。
>   通过call apply bind 修改过的this，想要第二次修改的话，不起任何作用。
>   事件绑定的this，，是当前操作的元素
>   自执行函数中的this 指向window
>   定时器中的this 同样也指向window
>   其余的就看‘点’，点前面是谁，this就指向谁，没有点就是指向window

### class类
>   声明的类不能当做普通函数去执行，只能通过new执行
    class Animal{
        constructor(age){
            // 实例的私有属性
            this.age=age
        }
        eat(){
            // 实例的共有属性
            console.log('animal eat');
        }
        static getName(){
            // 把类当做对像增加的属性
            console.log('class 静态方法');           
        }
    }

